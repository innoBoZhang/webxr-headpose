<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebXR Head Pose Viewer</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #0f0;
      padding: 2em;
      line-height: 1.5em;
    }

    #enter-vr {
      font-size: 1.2em;
      padding: 1em 2em;
      background: #0f0;
      color: #000;
      border: none;
      cursor: pointer;
      margin-bottom: 1em;
    }

    pre {
      background: #222;
      padding: 1em;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <!-- Button to enter VR -->
  <button id="enter-vr">Enter VR</button>

  <!-- Display area for head pose data -->
  <pre id="output">Waiting to start XR session...</pre>

  <script>
    // Global variables for the XR session, reference space, and WebGL context
    let xrSession = null;
    let xrRefSpace = null;
    let gl = null;

    // Event listener for the "Enter VR" button
    document.getElementById("enter-vr").addEventListener("click", async () => {
      // Check if WebXR is supported in the browser
      if (!navigator.xr) {
        document.getElementById("output").textContent = "WebXR not supported.";
        return;
      }

      // Check if immersive-vr mode is supported
      const supported = await navigator.xr.isSessionSupported('immersive-vr');
      if (!supported) {
        document.getElementById("output").textContent = "Immersive VR not supported.";
        return;
      }

      try {
        // Request to start an immersive VR session
        xrSession = await navigator.xr.requestSession('immersive-vr');

        // Create a canvas and get a WebGL context for XR rendering
        const canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl', { xrCompatible: true });

        // Tell WebXR to use this WebGL context
        await xrSession.updateRenderState({
          baseLayer: new XRWebGLLayer(xrSession, gl)
        });

        // Get the local reference space (head-relative tracking)
        xrRefSpace = await xrSession.requestReferenceSpace('local');

        // Start the XR frame loop
        xrSession.requestAnimationFrame(onXRFrame);
      } catch (e) {
        document.getElementById("output").textContent = "Failed to start XR session: " + e;
      }
    });

    // Called once per frame to update head pose data
    function onXRFrame(time, frame) {
      const session = frame.session;

      // Request the next animation frame
      session.requestAnimationFrame(onXRFrame);

      // Get the viewer's pose (head position and orientation)
      const pose = frame.getViewerPose(xrRefSpace);
      if (pose) {
        const view = pose.views[0]; // Usually the left or center eye
        const pos = view.transform.position;     // Position (x, y, z)
        const ori = view.transform.orientation;  // Orientation (quaternion: x, y, z, w)

        // Display the pose data on the webpage
        document.getElementById("output").textContent = `
Head Pose Data:

Position (meters):
  x: ${pos.x.toFixed(3)}
  y: ${pos.y.toFixed(3)}
  z: ${pos.z.toFixed(3)}

Orientation (quaternion):
  x: ${ori.x.toFixed(3)}
  y: ${ori.y.toFixed(3)}
  z: ${ori.z.toFixed(3)}
  w: ${ori.w.toFixed(3)}
        `;
      }
    }
  </script>
</body>
</html>
